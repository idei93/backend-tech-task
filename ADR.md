# ADR

## Унікальні Рішення

### 1. Менеджер Пакетів: Poetry (Замість pip/pipenv)

**Альтернативи:**
- **pip + requirements.txt**: Стандартний, але не має вирішення залежностей
- **pipenv**: Добре, але повільніше, менш підтримується

**Рішення: Poetry**

**Обґрунтування:**
- Детерміноване вирішення залежностей з lock-файлом
- Краще управління конфліктами залежностей
- Вбудоване керування віртуальним середовищем


### 2. ODM: Beanie (Замість сирого Motor/PyMongo)

**Альтернативи:**
- **Motor/PyMongo**: Сирі асинхронні запити, без типобезпеки
- **Mongoengine**: Тільки синхронний, застарілий
- **ODMantic**: Схожий, але менше функцій

**Рішення: Beanie**

**Обґрунтування:**
- Повне автодоповнення в IDE з моделями Pydantic
- Побудований на Motor, ідеально для FastAPI
- Автоматичне створення індексів з визначень моделей
- Пітонічні запити замість сирих словників


### 3. Серіалізація: MessagePack (Замість JSON)

**Альтернативи:**
- **JSON**: Стандартний, читабельний людиною, багатослівний
- **Protobuf**: Швидкий, але потребує файлів схеми
- **Avro**: Додаткові витрати на реєстр схем

**Рішення: MessagePack**

**Обґрунтування:**
- На 30% менший за JSON для тих самих даних
- Швидша серіалізація/десеріалізація
- Без схеми: Не потрібні .proto файли
- Пряма заміна: Схожий API з JSON

**Мінуси:**
- Не читабельний людиною


### 4. Веб-фреймворк: FastAPI (Замість Flask/Django)

**Альтернативи:**
- **Flask**: Синхронний, потребує розширень для async, застаріла валідація
- **Django**: Монолітний, надмірний для API, повільніший
- **Sanic**: Швидкий async, але менша екосистема, нестабільний API
- **Tornado**: Застарілий синтаксис, менше комьюніті

**Рішення: FastAPI**

**Обґрунтування:**
- Нативна підтримка async/await без додаткових розширень
- Автоматична генерація документації OpenAPI/Swagger
- Вбудована валідація через Pydantic з детальними помилками
- Анотації типів забезпечують автодоповнення IDE та перевірку типів
- Висока продуктивність
- Сучасний стек для мікросервісів

**Мінуси:**
- Молодіший фреймворк


### 5. База Даних: MongoDB (Замість PostgreSQL/MySQL)

**Альтернативи:**
- **PostgreSQL**: Реляційна, сувора схема, складніші міграції для JSON
- **MySQL**: Реляційна, гірша підтримка JSON, менша гнучкість
- **Cassandra**: NoSQL колонкова, складніша для агрегацій

**Рішення: MongoDB**

**Обґрунтування:**
- Гнучка схема для поля properties (кожна подія може мати різні поля)
- Висока продуктивність запису (важливо для event ingestion)
- Горизонтальне масштабування через шардування без downtime
- Нативна підтримка Beanie ODM для типобезпечних запитів
- Добрі можливості для агрегації даних (DAU статистика)
- Менші витрати на міграції схеми

**Мінуси:**
- Менш суворі транзакції
- Більше використання дискового простору


### 6. Черга Повідомлень: RabbitMQ (Замість Kafka/Redis)

**Альтернативи:**
- **Apache Kafka**: Складніше налаштування, надмірний для цього масштабу
- **Redis Streams**: Простіше, але менше функцій надійності
- **AWS SQS**: Vendor lock-in, дорожче, більші затримки
- **NATS**: Швидкий, але менша екосистема Python

**Рішення: RabbitMQ**

**Обґрунтування:**
- Надійна доставка повідомлень з acknowledgments
- Вбудована підтримка Dead Letter Queue (DLQ) для проблемних повідомлень
- Web UI для моніторингу черг в реальному часі
- Відмінна асинхронна підтримка через бібліотеку aio-pika
- Простіше налаштування порівняно з Kafka
- Добре підходить для середніх навантажень (тисячі msg/sec)

**Мінуси:**
- Менша пропускна здатність ніж Kafka (але достатня для більшості випадків)
- Більше пам'яті на повідомлення


## Архітектура Системи

```
Клієнт → FastAPI 
         ↓ (валідує з Pydantic)
         ↓ (серіалізує з MessagePack)
         Черга RabbitMQ
         ↓
         Worker (десеріалізує MessagePack)
         ↓
         MongoDB (через Beanie ODM)
```
